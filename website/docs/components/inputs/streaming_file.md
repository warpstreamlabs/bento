---
title: streaming_file
slug: streaming_file
type: input
status: experimental
categories: ["Local"]
---

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the corresponding source file under internal/impl/<provider>.
-->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::caution EXPERIMENTAL
This component is experimental and therefore subject to change or removal outside of major version releases.
:::
Streaming file input with log rotation and truncation handling

```yml
# Config fields, showing default values
input:
  label: ""
  streaming_file:
    path: /var/log/app.log # No default (required)
    max_buffer_size: 1000
    max_line_size: 1048576
    poll_interval: 1s
    disable_fsnotify: true
```

Reads from a file continuously with automatic handling of log rotation and truncation.

## Core Features

- **Log Rotation**: Detects when a file is rotated (renamed/recreated) via inode changes and seamlessly switches to the new file
- **Truncation**: Detects when a file is truncated and resets to read from the beginning
- **Position Metadata**: Each message includes file position metadata (path, inode, byte_offset) that can be used with Bento's cache system to implement custom persistence

## Position Tracking

This component exposes file position as metadata on each message. To implement crash recovery, you can:

1. Store the position in a cache on each message
2. On startup, read the cached position and use a processor to filter already-processed lines

This approach keeps the input stateless while enabling persistence through pipeline composition.

## Metadata Fields

Each message includes the following metadata:

- `streaming_file_path` - The file path being read
- `streaming_file_inode` - The file's inode (for rotation detection)
- `streaming_file_offset` - Byte offset where this line started

## Performance Considerations

By default, this component uses polling-only mode for better CPU efficiency at high write rates.
This is based on findings from large-scale deployments where inotify/fsnotify can cause significant
CPU overhead when files are written to frequently (each write triggers an event, leading to excessive
fstat calls). See `disable_fsnotify` option below.

For low-volume log files where you want sub-second latency, you can enable fsnotify by setting
`disable_fsnotify: false`.

### Platform Limitations

When fsnotify is enabled:

- **NFS/Network Filesystems**: fsnotify does not work reliably on NFS or other network filesystems
- **Supported Platforms**: Linux (inotify), macOS (FSEvents), Windows (ReadDirectoryChangesW), BSD variants (kqueue)
- **Container Environments**: Ensure the file path is mounted from the host, not a container-internal path


## Fields

### `path`

Path to the file to read from


Type: `string`  

```yml
# Examples

path: /var/log/app.log
```

### `max_buffer_size`

Maximum number of lines to buffer


Type: `int`  
Default: `1000`  

```yml
# Examples

max_buffer_size: 1000
```

### `max_line_size`

Maximum line size in bytes to prevent OOM


Type: `int`  
Default: `1048576`  

```yml
# Examples

max_line_size: 1048576
```

### `poll_interval`

How often to poll the file for new data. This is the primary mechanism for detecting new data. Lower values mean lower latency but higher CPU usage.


Type: `string`  
Default: `"1s"`  

```yml
# Examples

poll_interval: 1s

poll_interval: 200ms
```

### `disable_fsnotify`

When true (default), only use polling to detect file changes. This is more CPU-efficient for high-throughput log files where inotify would fire constantly. Set to false to enable fsnotify for lower latency on low-volume files.


Type: `bool`  
Default: `true`  

```yml
# Examples

disable_fsnotify: true

disable_fsnotify: false
```


