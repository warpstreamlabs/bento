---
title: http_server
slug: http_server
type: output
status: stable
categories: ["Network"]
---

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the corresponding source file under internal/impl/<provider>.
-->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Sets up an HTTP server that will send messages over HTTP(S) GET requests. HTTP 2.0 is supported when using TLS, which is enabled when key and cert files are specified.


<Tabs defaultValue="common" values={[
  { label: 'Common', value: 'common', },
  { label: 'Advanced', value: 'advanced', },
]}>

<TabItem value="common">

```yml
# Common config fields, showing default values
output:
  label: ""
  http_server:
    address: ""
    path: /get
    stream_path: /get/stream
    stream_format: raw_bytes
    ws_path: /get/ws
    ws_message_type: binary
    allowed_verbs:
      - GET
```

</TabItem>
<TabItem value="advanced">

```yml
# All config fields, showing default values
output:
  label: ""
  http_server:
    address: ""
    path: /get
    stream_path: /get/stream
    stream_format: raw_bytes
    heartbeat: 0s
    ws_path: /get/ws
    ws_message_type: binary
    allowed_verbs:
      - GET
    timeout: 5s
    cert_file: ""
    key_file: ""
    cors:
      enabled: false
      allowed_origins: []
      allowed_headers: []
      allowed_methods:
        - GET
        - HEAD
        - POST
        - PUT
        - PATCH
        - DELETE
    write_wait: 10s
    pong_wait: 60s
    ping_period: 54s
```

</TabItem>
</Tabs>

Sets up an HTTP server that will send messages over HTTP(S) GET requests. If the `address` config field is left blank the [service-wide HTTP server](/docs/components/http/about) will be used.

Three endpoints will be registered at the paths specified by the fields `path`, `stream_path` and `ws_path`. Which allow you to consume a single message batch, a continuous stream of line delimited messages, or a websocket of messages for each request respectively.

When messages are batched the `path` endpoint encodes the batch according to [RFC1341](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html). This behaviour can be overridden by [archiving your batches](/docs/configuration/batching#post-batch-processing).

Please note, messages are considered delivered as soon as the data is written to the client. There is no concept of at least once delivery on this output.

:::caution Endpoint Caveats
Components within a Bento config will register their respective endpoints in a non-deterministic order. This means that establishing precedence of endpoints that are registered via multiple `http_server` inputs or outputs (either within brokers or from cohabiting streams) is not possible in a predictable way.

This ambiguity makes it difficult to ensure that paths which are both a subset of a path registered by a separate component, and end in a slash (`/`) and will therefore match against all extensions of that path, do not prevent the more specific path from matching against requests.

It is therefore recommended that you ensure paths of separate components do not collide unless they are explicitly non-competing.

For example, if you were to deploy two separate `http_server` inputs, one with a path `/foo/` and the other with a path `/foo/bar`, it would not be possible to ensure that the path `/foo/` does not swallow requests made to `/foo/bar`.
:::


## Examples

<Tabs defaultValue="Server Side Events (SSE)" values={[
{ label: 'Server Side Events (SSE)', value: 'Server Side Events (SSE)', },
]}>

<TabItem value="Server Side Events (SSE)">

Here we set up an HTTP server that streams data using the Server-Sent Events protocol.
The server listens on the path `/teststream`and sends messages in the EventSource format.
CORS is enabled to allow connections from any origin.


### Example HTML Consumer Client

Running the following will listen on the path /teststream` and print out an element for each message consumed from the Bento server via SSE:
<details>

<summary>JS/HTML Snippet</summary>

<p>
```html
<!doctype html>
<html>
  <body>
    <ul id="list"></ul>
  </body>
  <script type="text/javascript">
    const eventSrc = new EventSource("http://0.0.0.0:4195/teststream");
    const list = document.getElementById("list");
    eventSrc.onmessage = (event) => {
      const li = document.createElement("li");
      li.textContent = `message: ${event.data}`;
      list.appendChild(li);
    };
  </script>
</html>
```
</p>

</details>


```yaml
output:
  http_server:
    stream_path: /teststream
    stream_format: event_source
    cors:
      enabled: true
      allowed_origins:
        - "*"
```

</TabItem>
</Tabs>

## Fields

### `address`

An alternative address to host from. If left empty the service wide address is used.


Type: `string`  
Default: `""`  

### `path`

The path from which discrete messages can be consumed.


Type: `string`  
Default: `"/get"`  

### `stream_path`

The path from which a continuous stream of messages can be consumed.


Type: `string`  
Default: `"/get/stream"`  

### `stream_format`

The format of the stream endpoint. `raw_bytes` delivers messages directly with newlines between batches, while `event_source` formats according to Server-Sent Events (SSE) specification with `data:` prefixes, compatible with EventSource API.


Type: `string`  
Default: `"raw_bytes"`  
Options: `raw_bytes`, `event_source`.

### `heartbeat`

The time to wait before sending a heartbeat message.


Type: `string`  
Default: `"0s"`  

### `ws_path`

The path from which websocket connections can be established.


Type: `string`  
Default: `"/get/ws"`  

### `ws_message_type`

Type of websocket message


Type: `string`  
Default: `"binary"`  
Requires version 1.6.0 or newer  
Options: `binary`, `text`.

### `allowed_verbs`

An array of verbs that are allowed for the `path` and `stream_path` HTTP endpoint.


Type: `array`  
Default: `["GET"]`  

### `timeout`

The maximum time to wait before a blocking, inactive connection is dropped (only applies to the `path` endpoint).


Type: `string`  
Default: `"5s"`  

### `cert_file`

Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.


Type: `string`  
Default: `""`  

### `key_file`

Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.


Type: `string`  
Default: `""`  

### `cors`

Adds Cross-Origin Resource Sharing headers. Only valid with a custom `address`.


Type: `object`  
Requires version 1.0.0 or newer  

### `cors.enabled`

Whether to allow CORS requests.


Type: `bool`  
Default: `false`  

### `cors.allowed_origins`

An explicit list of origins that are allowed for CORS requests.


Type: `array`  
Default: `[]`  

### `cors.allowed_headers`

Appends additional headers to the list of default allowed headers: Accept, Accept-Language, Content-Language & Origin. These default headers are therefore always allowed.


Type: `array`  
Default: `[]`  
Requires version 1.13.0 or newer  

### `cors.allowed_methods`

Used to explicitly set allowed methods in the Access-Control-Allow-Methods header.


Type: `array`  
Default: `["GET","HEAD","POST","PUT","PATCH","DELETE"]`  
Requires version 1.13.0 or newer  

### `write_wait`

The time allowed to write a message to the websocket.


Type: `string`  
Default: `"10s"`  

### `pong_wait`

The time allowed to read the next pong message from the client.


Type: `string`  
Default: `"60s"`  

### `ping_period`

Send pings to client with this period. Must be less than pong wait.


Type: `string`  
Default: `"54s"`  


